# 3장 회귀 알고리즘과 모델 규제
## K-최근접 이웃 회귀
K-최근접 이웃 알고리즘이 회귀에도 작동함.

분류와 똑같이 예측하려는 샘플에 가장 가까운 샘플 K개를 선택함. 다른 점은 이웃한 **샘플의 타깃**은 어떤 클래스가 아니라 **임의의 수치**임.

## reshape()
파이썬의 numpy를 이용 시, **배열 차원(Dimension)을 재구조화 및 변경**하고자 할 때 사용. 매개변수로 변경하고자 하는 배열의 행과 열의 차원을 정수로 입력해주면 됨.

- **매개변수 '-1'** 이 의미하는 바는 변경된 배열의 '-1' 위치의 차원은 **"원래 배열의 길이와 남은 차원으로부터 추정"** 이 된다는 뜻
- reshape(-1, 정수) : 정수에 따라서 원소가 해당 열 개수만큼 자동으로 구조화
- reshape(정수, -1) : 행의 정수만큼 행이 생성되어 자동으로 구조화
- reshape(-1) : 1차원 배열 반환

**다만 조건으로는 원소의 개수와 reshape 안의 행과 열의 조합을 통한 행렬의 원소 개수가 동일해야 함.**

예를 들어 np.arrange(7).reshape(2,4)라고 한다면 원소는 7개인데 재구조화하려는 행렬은 2x4 행렬. 즉, 8개의 원소를 필요로 하기 때문에 생성이 안되고 오류가 발생.

+) 차원, 형상이라고 볼 수 있음. 머신러닝보다는 딥러닝에서 자주 쓰이며, 그 중에서도 컴퓨터비전 분야에서 많이 쓰임. resize랑 비슷한 역할을 하며, pytorch의 view()가 있음.

### 딥러닝에서의 reshape()
pytorch의 reshape()과 view() 둘 다 Tensor의 모양을 변경하는 데에 사용될 수 있음. 그러나 둘 사이엔 약간의 차이가 존재함.

- **reshape()** : 가능하면 input의 view를 반환하고, 안되면 contiguous한 tensor로 copy하고 view를 반환한다.
- **view()** : view는 기존의 데이터와 같은 메모리 공간을 공유하며 stride 크기만 변경하여 보여주기만 다르게 한다. 그래서 contigious해야만 동작하며, 아닌 경우 에러를 발생함.

view는 메모리가 기존 Tensor와 동일한 메모리를 공유하는게 보장되지만 reshape은 그렇지 않음.
- 안전하게 형태만 바꾸고 싶다면 **reshape()**
- 메모리가 공유되어 업데이트에 대한 보장이 이루어지고 싶다면 **view**

[+) 참고할만한 사이트](https://subinium.github.io/pytorch-Tensor-Variable/)

## 결정계수(R²)
**R² = 1 - {(타깃 - 예측)²의 합 / (타깃 - 평균)²의 합}** = SSE/SST = 1 - (SSR/SST)

변수간 영향을 주는 정도 또는 인과관계의 정도를 정량화해서 나타낸 수치. 따라서, **결정계수**는 상관분석이 아닌 **회귀분석에서 사용하는 수치**라고 할 수 있음.

각 타깃의 평균 정도를 예측하는 수준이라면 (즉 분자와 분모가 비슷해져) R²은 0에 가까워지고, 예측이 타깃에 아주 가까워지면 (분자가 0에 가까워지기 때문에) 1에 가까운 값이 됨.

- SST = SSR(설명가능) + SSE(모델로서는 설명 불가능, 직선으로 설명X)
회귀의 결정계수

    -> SSR/SST(고정), 우리 모델로 에러 설명 가능.
- 모델로서 설명할 수 없는 게 낮아야 R² 좋음.
- 왜 음수가 나올까? 모델이 평균적으로 맞춘 것에 비해 모델 성능이 낮을 때 음수가 나옴. ȳ(y의 평균값)보다 우리 모델이 못 맞출 때 음수가 나옴.

- 회귀모델에서 독립변수가 종속변수를 얼마나 잘 설명해주는지 보여주는 지표
- 결정계수가 높을수록 독립변수가 종속변수를 잘 설명한다는 뜻이지만, **이때 독립변수의 개수가 증가하면 함께 증가함.**
- 결정계수에만 의존하여 회귀모델을 평가하기에는 무리가 있음. 따라서 **조정된 결정계수**(Adjusted R-squared)가 제시됨.
- 0~1 사이의 값을 나타내지만, 음수값이 나오기도 함.(식을 생각해보면 이해 가능)
- 1에 가깝다고 무조건 좋은 건 아님. 상황마다 다름.

### 조정된 결정계수(Adjusted R-squared)
결정계수는 독립변수 개수가 증가하면 함께 증가하므로 **독립변수 개수가 2개 이상일 경우 Adjusted R-squared를 사용해야함.**

## bias와 variance
편향과 분산은 항상 trade-off 관계. 하나가 커지면 하나는 작아지기 때문에 최적의 값을 찾아줘야함.

bias : 모델 예측 오차

variance : 모델 예측의 편차

bias가 낮고 variance도 낮으면 좋음. **but, 둘 다 큰 경우가 생겼을 경우 뭐가 더 최악일까?(worst case)** 생각해보자.

variance가 낮으면 더 안좋음. bias가 높으면 영점 조절만 하면 됨. but, variance가 높으면 사람이 문제임. variance는 모델의 복잡성이라고도 부름. 일반적으로 bias는 높더라도 variance를 낮추는 방향으로 가는 것이 좋음.

## K-최근접 이웃의 한계 (p.131)
가장 가까운 샘플을 찾아 타깃을 평균냄. 따라서 새로운 샘플이 train set의 범위를 벗어나면 엉뚱한 값을 예측할 수 있음.

### 머신러닝은 주기적으로 학습해야함.
시간과 환경이 변화하면서 데이터도 바뀌기 때문에 주기적으로 새로운 훈련 데이터로 모델을 다시 훈련해야함.

## 선형 회귀
**특성이 하나인 경우 어떤 직선을 학습하는 알고리즘**
sklearn.linear_model 패키지 아래에 **LinearRegression** 클래스 존재.

`훈련 fit()`, `평가 score()`, `예측 predict()`

위의 메서드들은 **사이킷런 모델 클래스들 모두 동일**.

- LinearRegression 클래스가 찾은 a, b(y=ax+b)는 `lr` 객체의 `coef_`와 `intercept_` 속성에 저장.
- 이 속성들은 머신러닝 알고리즘이 찾은 값이라는 의미로 **모델 파라미터**라고 부름.
- 많은 머신러닝 알고리즘의 훈련 과정은 **최적의 모델 파라미터를 찾는 것**과 같음.
- 이를 **모델 기반 학습**이라고 부름.
- coef_ 속성 이름에서 알 수 있듯이 **머신러닝에서 기울기**를 종종 **계수**(coefficient) 또는 **가중치**(weight)라고 부름.

## 다항 회귀 (Polynomial Regression)
**다항식을 사용한 선형 회귀**

다항회귀가 **선형**(linear)인가, **비선형**(non-linear)인가?

책에서는 함수의 형태가 비선형일 수 있지만, 여전히 선형 관계로 표현할 수 있다고 함.

회귀모델에서는 선형과 비선형을 구분할 때는 독립 변수와 종속변수의 관계를 기준으로 생각하면 안되고,

`변수`가 아닌 `회귀 계수`로 결정해야 한다고 함.

회귀 계수는 **절편**과 **기울기**를 의미함. (parameter, weight)

### 특성공학 (feature engineering)
기존의 특성을 사용해 새로운 특성을 뽑아내는 작업 ex) 제곱

### train set에 적용했던 변환기로 test set을 변환해야하는가?
PolynomailFeatures 클래스는 fit() 메서드에서 만들 특성의 조합을 준비하기만 할 뿐, **별도의 통계값을 구하지 않음.** 따라서 테스트 세트를 따로 변환해도 됨. 하지만 **항상 train set을 기준으로 test set을 변환하는 습관을 들이는 것이 좋음.**

### 샘플 개수와 특성 개수
차원의 저주와도 관련이 있음. 열(column)의 개수가 행(row)의 개수보다 많을 때.

샘플 개수가 무조건 많아야 함. 각각의 특성에 맞게끔 설명 불가능 → 왜곡된 정보 나옴. 정보가 너무 빈약하기 때문에.

## 다중 회귀 (Multiple Regression)
**특성(feature)** 값이 하나가 아니라 **여러 개**를 사용한 선형 회귀를 다중 회귀라 부름.
- 다중의 독립 변수가 있는 형태임.
- 독립 변수 간 상관관계가 높아 발생하는 **`다중공선성(Multicollinearity)`** 문제가 발생하기도 함.

### 다중공선성 (Multicollinearity)
**독립 변수 간의 상관관계가 높아 발생하는 문제**를 말함. 데이터에 다중공선성이 있는 경우, **회귀 계수의 영향력이 커져 과다 추정**될 수 있음. 이런 경우 과대적합 문제 발생.

모든 머신러닝 문제는 오버피팅과 언더피팅에서 완전히 자유로울 수는 없음. 그러나 어느정도의 적절한 해결책을 가지고 있는데 그 중 회귀모델에서 널리 사용되는 방법이 **`규제(Regularization)`** 라는 방법.

### 규제(Regularization)
회귀 계수를 구할 때, 회귀 계수의 크기에 제약을 두어 설명력이 낮은 독립변수에 대한 가중치를 줄임.

규제는 회귀 계수를 추정하기 위한 최적화 식에 회귀 계수의 크기에 대한 제약식을 추가하는 것을 의미. 아래는 원리에 대한 설명임.
- 언더피팅을 피하기 위해 고차 회귀 모델을 세움.
- 모델의 차원을 높임으로써 언더피팅 가능성은 감소했지만 오버피팅 우려가 존재.
- 오버피팅이 발생하면 train data에만 잘 맞도록 학습되므로 train data가 조금만 바뀌더라도 학습 결과가 크게 바뀔 수 있음.
- 즉, 회귀 계수의 분산이 커지게 됨. 회귀 계수의 값이 매우 커질 수 있음을 의미.
- 반대로 회귀 계수의 값이 매우 커지는 것을 방지하면 회귀 계수의 분산이 작아지므로 오버피팅을 방지할 수 있게 됨.
- 설명력이 부족한 독립변수에 대한 회귀 계수의 크기를 효과적으로 억압하는 것은 변수 선택에 의해 차원을 축소한 것과 같은 효과를 얻을 수 있기 때문에 오버피팅이 줄어든다고 해석 가능.

### Ridge Regression VS LASSO regression
- Ridge는 L2 Norm, LASSO는 L1 Norm을 사용
- Ridge는 불필요한 변수에 대한 가중치를 0에 가깝게 줄이는 반면, LASSO는 불필요한 변수에 대한 가중치를 완전히 0으로 억압하여 변수선택 기능 제공
- Ridge는 미분 가능하므로 보다 매끄럽게 최적점에 도달하는 반면, LASSO는 0에서 미준 가능하지 않으므로 진동하며 수렴
- Ridge는 closed-form solution 제공, 미분 가능하므로 경사하강법 적용 가능
- LASSO는 numerical optimization 문제를 풀어야 하며, sub-gradient vector를 사용하여 경사하강법 적용
- Ridge는 변수 간 상관관계가 높은 경우 좋은 예측 성능을 보이는 것으로 알려져 있으나, LASSO는 이 경우 변수 선택 성능이 저하되어 좋지 못한 성능을 제공.

그렇다면 Ridge, LASSO, Elastic-Net을 언제 사용해야 할까?

대부분의 머신러닝 문제에서 **약간의 regularization이 있는 것이 그렇지 않은 경우보다 더 좋은 성능을 제공**한다. 따라서 일반적인 선형회귀는 피하는 것이 좋으며, **기본적으로는 Ridge regression을 많이 사용**한다. Ridge regression이 제 1 옵션이지만 중요한 변수의 개수가 몇 개뿐이고 변수 간 상관관계가 적다고 판단되면 LASSO를 사용하는게 낫다. 중요한 특성의 수가 적지만 특성 간 상관관계가 있다고 판단되면 Elastic-Net이 더 선호된다.